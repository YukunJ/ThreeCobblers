{"paragraphs":[{"user":"anonymous","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/python"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1647733534363_1801020372","id":"20220319-234534_210724849","dateCreated":"2022-03-19T23:45:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:251","text":"%livy2.pyspark\nfrom pyspark.sql.functions import from_json, col, size, explode, lower, desc, when, log, to_date, to_timestamp, isnull, desc, row_number\nfrom pyspark.sql import Window\nimport locale\n\nlocale.setlocale(locale.LC_ALL,'en_US.UTF-8'); # set the encoding for UTF-8\n\n#read the dataset\ndf_ref = spark.read.json(\"microservice3_ref.txt\").cache()\n\n#find the contact tweet\ndf_contact = df_ref.filter(~(isnull(df_ref.in_reply_to_user_id) & isnull(df_ref.retweeted_status)))\n\n#extract user id from user\ndf_contact = df_contact.withColumn(\"user_id\", df_contact.user[\"id\"])\n\n#extract retweeted_user from retweeted_status\ndf_contact = df_contact.withColumn('retweeted_user', when(isnull(df_contact.retweeted_status), None).otherwise(df_contact.retweeted_status[\"user\"]))\n\n#extract retweeted_user_id from retweeted_user\ndf_contact = df_contact.withColumn('retweeted_user_id', when(isnull(df_contact.retweeted_user), None).otherwise(df_contact.retweeted_user[\"id\"]))\n\n#only keep id fields\ndf_contact = df_contact[[\"user_id\", \"in_reply_to_user_id\", \"retweeted_user_id\"]]\n\n#find the reply tweet, duplicate them, since they contribute 2 points to the score\ndf_reply = df_contact.filter(~isnull(df_contact.in_reply_to_user_id))\ndf_contact_more_reply = df_contact.unionByName(df_reply)\n\n#combine in_reply_to_user_id with retweeted_user_id to form contact_user_id\ndf_contact_more_reply = df_contact_more_reply.withColumn('contact_user_id', when(isnull(df_contact_more_reply.retweeted_user_id), df_contact_more_reply.in_reply_to_user_id).otherwise(df_contact_more_reply.retweeted_user_id))[[\"user_id\", \"contact_user_id\"]]\n\n#find contact tweet involving only one user\ndf_contact_more_reply_self = df_contact_more_reply.filter(df_contact_more_reply.user_id == df_contact_more_reply.contact_user_id)\n\n#find contact tweet involving two users\ndf_contact_more_reply_other = df_contact_more_reply.filter(~(df_contact_more_reply.user_id == df_contact_more_reply.contact_user_id))\n\n#for row A, B, make a row B, A, since we want to store score between A and B two times to speed up query, no need to do this for contact tweet involving only one user\ndf_contact_more_reply_other_all = df_contact_more_reply_other.unionByName(df_contact_more_reply_other.rdd.toDF([\"contact_user_id\", \"user_id\"]))\n\n#glue contact user together\ndf_contact_all = df_contact_more_reply_other_all.unionByName(df_contact_more_reply_self)\n\n#find the count\ndf_interaction = df_contact_all.groupby(\"user_id\", \"contact_user_id\").count()\n\n#compute the score\ndf_interaction_score = df_interaction.withColumn(\"interaction_score\", log(1 + df_interaction[\"count\"]))\n\n\ndf_ref_clean = df_ref.withColumn(\"user_id\", df_ref.user[\"id\"]).withColumn(\"tweet_id\", col(\"id\")) \\\n               .withColumn(\"ts\", to_timestamp(col(\"created_at\"), \"EEE MMM dd HH:mm:ss Z yyyy\"))\n               \n#extract retweeted_user from retweeted_status\ndf_ref_clean = df_ref_clean.withColumn('retweeted_user', when(isnull(df_ref_clean.retweeted_status), None).otherwise(df_ref_clean.retweeted_status[\"user\"]))\n\n#extract retweeted_user_id from retweeted_user\ndf_ref_clean = df_ref_clean.withColumn('retweeted_user_id', when(isnull(df_ref_clean.retweeted_user), None).otherwise(df_ref_clean.retweeted_user[\"id\"]))[[\"user_id\", \"in_reply_to_user_id\", \"retweeted_user_id\", \"text\", \"ts\", \"tweet_id\"]].cache()\n\ndf_reply = df_ref_clean.filter(~isnull(df_ref_clean.in_reply_to_user_id))\ndf_reply = df_reply.withColumn('contact_user_id', df_reply['in_reply_to_user_id'])[['user_id','contact_user_id', 'text', 'ts', 'tweet_id']]\n\n\n#find contact tweet involving only one user\ndf_reply_self = df_reply.filter(df_reply.user_id == df_reply.contact_user_id)\n\n#find contact tweet involving two users\ndf_reply_other = df_reply.filter(~(df_reply.user_id == df_reply.contact_user_id))\n\n#for row A, B, make a row B, A, since we want to store score between A and B two times to speed up query, no need to do this for contact tweet involving only one user\ndf_reply_all = df_reply_other.unionByName(df_reply_other.rdd.toDF(['contact_user_id', 'user_id', 'text', 'ts', 'tweet_id']))\n\n#glue contact user together\ndf_reply_all = df_reply_all.unionByName(df_reply_self)\n\nw = Window.partitionBy(\"user_id\", \"contact_user_id\").orderBy(col(\"ts\").desc(), col(\"tweet_id\").desc())\ndf_reply_latest = df_reply_all.withColumn('group_rowrank', row_number().over(w))\\\n                .filter(col(\"group_rowrank\") == 1)\\\n                .drop(\"group_rowrank\")\n    \ndf_reply_latest = df_reply_latest.withColumn(\"ts_reply\", df_reply_latest[\"ts\"]) \\\n                                .withColumn(\"id_reply\", df_reply_latest[\"tweet_id\"]) \\\n                                .withColumn(\"latest_reply\", df_reply_latest.text) \\\n                                .withColumn(\"user_id_reply\", df_reply_latest.user_id) \\\n                                .withColumn(\"contact_user_id_reply\", df_reply_latest.contact_user_id) \\\n                                .drop(\"ts\", \"tweet_id\", \"user_id\", \"contact_user_id\", \"text\")\n\n\ndf_retweet = df_ref_clean.filter(~isnull(df_ref_clean['retweeted_user_id']))\ndf_retweet = df_retweet.withColumn('contact_user_id', df_retweet['retweeted_user_id'])[['user_id','contact_user_id', 'text', 'ts', 'tweet_id']]\n\n\n#find contact tweet involving only one user\ndf_retweet_self = df_retweet.filter(df_retweet.user_id == df_retweet.contact_user_id)\n\n#find contact tweet involving two users\ndf_retweet_other = df_retweet.filter(~(df_retweet.user_id == df_retweet.contact_user_id))\n\n#for row A, B, make a row B, A, since we want to store score between A and B two times to speed up query, no need to do this for contact tweet involving only one user\ndf_retweet_all = df_retweet_other.unionByName(df_retweet_other.rdd.toDF(['contact_user_id', 'user_id', 'text', 'ts', 'tweet_id']))\n\n#glue contact user together\ndf_retweet_all = df_retweet_all.unionByName(df_retweet_self)\n\nw = Window.partitionBy(\"user_id\", \"contact_user_id\").orderBy(col(\"ts\").desc(), col(\"tweet_id\").desc())\ndf_retweet_latest = df_retweet_all.withColumn('group_rowrank', row_number().over(w))\\\n                .filter(col(\"group_rowrank\") == 1)\\\n                .drop(\"group_rowrank\")\n                \ndf_retweet_latest = df_retweet_latest.withColumn(\"ts_retweet\", df_retweet_latest[\"ts\"]) \\\n                                .withColumn(\"id_retweet\", df_retweet_latest[\"tweet_id\"]) \\\n                                .withColumn(\"latest_retweet\", df_retweet_latest.text) \\\n                                .withColumn(\"user_id_retweet\", df_retweet_latest.user_id) \\\n                                .withColumn(\"contact_user_id_retweet\", df_retweet_latest.contact_user_id) \\\n                                .drop(\"ts\", \"tweet_id\", \"user_id\", \"contact_user_id\", \"text\")\n                                \ndf_joined = df_interaction_score.drop(\"count\") \\\n                                .join(df_reply_latest, (df_interaction_score.user_id == df_reply_latest.user_id_reply) & (df_interaction_score.contact_user_id == df_reply_latest.contact_user_id_reply), how='left')\n                                \ndf_joined = df_joined.join(df_retweet_latest, (df_joined.user_id == df_retweet_latest.user_id_retweet) & (df_joined.contact_user_id == df_retweet_latest.contact_user_id_retweet), how='left') \\\n                                .drop(\"user_id_reply\", \"contact_user_id_reply\", \"user_id_retweet\",\"contact_user_id_retweet\")\n\ndf_joined = df_joined.withColumn(\"both_latest\",  \\\n                when(isnull(df_joined.ts_retweet), df_joined[\"latest_reply\"]) \\\n                    .otherwise(when(isnull(df_joined.ts_reply), df_joined[\"latest_retweet\"]) \\\n                        .otherwise(when(df_joined.ts_reply > df_joined.ts_retweet, df_joined[\"latest_reply\"]) \\\n                            .otherwise(when(df_joined.ts_reply < df_joined.ts_retweet, df_joined[\"latest_retweet\"]) \\\n                                .otherwise(when(df_joined.id_reply < df_joined.id_retweet, df_joined[\"latest_retweet\"]) \\\n                                    .otherwise(df_joined[\"latest_reply\"]) \\\n                                ) \\\n                            ) \\\n                        ) \\\n                    ) \\\n                ).drop(\"ts_reply\", \"id_reply\", \"ts_retweet\", \"id_retweet\")","dateUpdated":"2022-03-19T23:48:33+0000","dateFinished":"2022-03-19T23:49:37+0000","dateStarted":"2022-03-19T23:48:33+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<hr/>Spark Application Id: application_1647710431184_0008<br/>Spark WebUI: <a href=\"http://hn1-cloud.4vusr3dazs5e5mnzvafd5tovea.bx.internal.cloudapp.net:8088/proxy/application_1647710431184_0008/\">http://hn1-cloud.4vusr3dazs5e5mnzvafd5tovea.bx.internal.cloudapp.net:8088/proxy/application_1647710431184_0008/</a>"}]}},{"text":"%livy2.pyspark\ndf_joined.show()","user":"anonymous","dateUpdated":"2022-03-19T23:49:50+0000","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1647733678364_796933338","id":"20220319-234758_2074950952","dateCreated":"2022-03-19T23:47:58+0000","status":"RUNNING","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:324","dateStarted":"2022-03-19T23:49:50+0000","errorMessage":""},{"text":"%livy2.pyspark\n","user":"anonymous","dateUpdated":"2022-03-19T23:49:50+0000","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1647733790546_1171170321","id":"20220319-234950_155761234","dateCreated":"2022-03-19T23:49:50+0000","status":"READY","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:699"}],"name":"LatestTweet","id":"2GZVNUAS5","noteParams":{},"noteForms":{},"angularObjects":{"md:shared_process":[],"livy2:shared_process":[]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}